[메모리 구조](/Computer%20Science/Operating%20System/Memory/메모리%20구조.md)는 크게 4가지 영역으로 구성되어 있다. 
당장은 Stack과 Heap만 알아도 괜찮다.

- Stack: 함수 안에서의 지역 변수, 매개변수, 리턴값 등등이 들어간다. 함수 호출시에 push 종료에 pop한다. 컴파일 타임에 크기가 결정된다.

- Heap: 런타임에 결정되며, 데이터 크기가 확실치 않고 변동이 있을 때 사용한다. 스택보다 할당 공간은 많지만, 접근할 때는 포인터를 사용해야 하기에 읽고 쓰기가 느리다.

```Rust
 fn main() {  
    let mut a = "sdf";                   // str
    let mut b = String::from("hello");   // String
  
    a.push_str("qwer");  
    b.push_str("asdf");  
  
    println!("{} {}", b, a);  
}
```
다음과 같은 코드에서, a는 컴파일 과정에서 그 크기를 알기에 스택 메모리에 저장되고 불변성을 띄게 된다.
반면, `String`을 사용하여 할당한 b의 경우에는 힙에 저장되기 때문에 push_str을 통해 값 변경이 가능하다.

>a는 리터럴 값을 통해 생성된 변수는 str 타입이고, b는 String 타입이다.
>그렇기에, 힙 메모리를 사용하는 b에서는 지원하는 push_str을 a에서 사용할 수 없다.
>
>+ let mut를 사용하는 경우에는, `a = "sdfqwer";` 형식으로의 값 변경은 가능하다.
>+ 정확히는 컴파일 시에 "sdfqwer"에 맞는 메모리 공간을 할당 받고, 해당 메모리에 값을 재정의 한 것 이다.

![rust_ownership](/_images/rust_ownership.png)

----
힙 메모리를 사용하려면, 운영체제에서 알게 모르게 동작하는 부분들이 많다.
그러나 개발할 때 신경 쓸 부분은, **메모리 요청**과 **해제**이다.

메모리 요청은 구현되어 있는 `String::from` 호출을 통해서 사용하였다.
해제의 경우에는 해당 메모리의 소유권을 가진 소유자가 스코프를 벗어날 때 `drop`이라는 메소드를 호출하여 동작한다.

